import{c as a}from"./chunk-LRK34XDC.js";import{Be as w,F as b,Gc as f,Hc as x,Ic as C,Ja as M,R as k,Rc as j,Sc as l,Vc as d,Wc as I,Xc as N,Yc as A,Z as i,Zc as H,a as h,ad as m,b as u,ba as s,k as g,l as y,s as S,w as T,ye as E,ze as W}from"./chunk-CQN7FGIC.js";var G=t=>l(m,e=>{switch(t){case a.QUANTIZATION:return e.models.quantizationModels;case a.PRUNING:return e.models.pruningModels;case a.MACHINE_UNLEARNING:return e.models.machineUnlearningModels;case a.AWQ:return e.models.awqModels;default:return}}),v=l(m,t=>t.models.currentModel),O=l(m,t=>t.models.modelMetadata);var Y=(()=>{let e=class e{constructor(o){this.store=o,this.currentModel$=this.store.select(v),this.modelMetadata$=this.store.select(O)}getModelsByType(o){return this.store.select(G(o))}dispatch(o){this.store.dispatch(o)}};e.\u0275fac=function(r){return new(r||e)(s(j))},e.\u0275prov=i({token:e,factory:e.\u0275fac});let t=e;return t})();var Z=300,J=(()=>{let e=class e{constructor(o){this.ngZone=o,this.messageSubject=new y(Z),this.connectionStatus=new g(!1),this.isConnecting=!1,this.messages$=this.messageSubject.asObservable(),this.connectionStatus$=this.connectionStatus.asObservable()}connect(){if(this.socket&&(this.socket.readyState===WebSocket.OPEN||this.socket.readyState===WebSocket.CONNECTING)){console.log("Terminal WebSocket is already connected or connecting.");return}if(this.isConnecting){console.log("Terminal WebSocket connection is already in progress.");return}this.isConnecting=!0;let o=E.terminalWebSocketUrl;this.socket=new WebSocket(o),this.socket.onmessage=r=>{let c=r.data;this.ngZone.run(()=>{this.messageSubject.next(c)})},this.socket.onopen=()=>{console.log("Terminal WebSocket connected!"),this.ngZone.run(()=>this.connectionStatus.next(!0)),this.isConnecting=!1,this.sendMessage("CLIENT_READY")},this.socket.onerror=r=>{console.error("Terminal WebSocket Error:",r),this.ngZone.run(()=>this.connectionStatus.next(!1)),this.isConnecting=!1},this.socket.onclose=()=>{console.log("Terminal WebSocket closed."),this.ngZone.run(()=>this.connectionStatus.next(!1)),this.isConnecting=!1}}sendMessage(o){this.socket&&this.socket.readyState===WebSocket.OPEN?this.socket.send(o):console.error("Terminal WebSocket is not open. Unable to send message:",o)}clearScreen(){this.sendMessage("clear\r")}closeConnection(){this.socket&&(this.socket.close(),console.log("Terminal WebSocket connection closed by client."))}reconnect(){this.closeConnection(),this.connect()}};e.\u0275fac=function(r){return new(r||e)(s(M))},e.\u0275prov=i({token:e,factory:e.\u0275fac});let t=e;return t})();var p=class extends W{constructor(){super("terminal-history",void 0,void 0,!1)}};var n=x({source:"[Core -> Terminal]",events:{"Get Terminal History":C(),"Get Terminal History Success":f(),"Get Terminal History Failure":f()}});var ae=(()=>{let e=class e{constructor(o,r){this.apiClient=o,this.actions$=r,this.getTerminalHistory=N(()=>this.actions$.pipe(H(n.getTerminalHistory),k(()=>this.apiClient.serviceCall(new p).pipe(T(c=>{let U=atob(c.history);return n.getTerminalHistorySuccess({terminalHistory:U})}),b(c=>S(n.getTerminalHistoryFailure({error:c})))))))}};e.\u0275fac=function(r){return new(r||e)(s(w),s(A))},e.\u0275prov=i({token:e,factory:e.\u0275fac});let t=e;return t})();var $={terminalHistory:"",error:null},he=I($,d(n.getTerminalHistorySuccess,(t,{terminalHistory:e})=>u(h({},t),{terminalHistory:e,error:null})),d(n.getTerminalHistoryFailure,(t,{error:e})=>u(h({},t),{error:e})));export{Y as a,n as b,ae as c,he as d,J as e};
